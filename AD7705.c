/**
 *******************************************************************************************************************
 *  @file AD7705.c
 *  @brief Библиотека для работы с 16 битным сигма-дельта АЦП с встроенной цифровой фильтрацией AD7705/MS7705/TM7705
 *  @author Волков Олег
 *  @date 23.04.2024
 *
 *******************************************************************************************************************
 * @attention
 *
 *  AD7705 имеет 2 полностью дифференциальных входа АЦП
 *  Нелинейность 0.003%
 *  Программное усиление от 1 до 128
 *  Имеется буфер аналогового входа
 *  Есть фильтры. Советую использовать только 50 Гц
 *  Питание от 2.7В до 3.3В, либо от 4.75В до 5.25В (По ощущениям, будто от 5В шума меньше).
 *  Также заметил, что при сильном изменении питающего напряжения могут уплывать значения после калибровки,
 *  не смотря на стабильный Vref.
 *  Поэтому питание VDD должно быть стабильным.
 *  Для нормальной работы АЦП требуется кварцевый резонатор 4.9512 МГц, либо 2.4576 МГц.
 *  Нагрузочные конденсаторы я ставил 30pF.
 *
 *  Общение по SPI:
 *  				CS (NSS) в активном режиме подтянут к земле
 *  				CPOL = 1
 *  				CPHA = 1
 *  				Работа с данными осуществляется в 8-битном формате.
 *
 *  YouTube: https://www.youtube.com/channel/UCzZKTNVpcMSALU57G1THoVw
 *  GitHub: https://github.com/Solderingironspb
 *  ВК: https://vk.com/solderingiron.stm32
 *  Документация: https://github.com/Solderingironspb/AD7705/blob/main/AD7705_datasheet.pdf
 *******************************************************************************************************************
 */

#include "AD7705.h"

extern volatile uint32_t Timeout_counter_ms; //Переменная для таймаута функций
bool AD7705_DRDY_Status = false;


/*
 **************************************************************************************************
 *  @breif Функция инициализации АЦП AD7705
 *  @attention Инициализация, как я понял, выполняется каждый раз перед сменой канала,
 *  иначе будет показывать неправильно
 *  @param  *SPI или *hspi - шина SPI
 *  @param  Channel - канал, который настраиваем (define)
 *  @param  Crystal - какой кварцевый резонатор подключен (define)
 *  @param  Buffer_on_off - включить или отключить буферизацию для согласования импеданса (define)
 *  @param  Bipolar_Unipolar - биполярный или униполярный режим
 *  @param  Gain - усиление сигнала
 *  @param  Calibration - метод калибровки канала.
 **************************************************************************************************
 */
void AD7705_Init(SPI_TypeDef* SPI, uint8_t Channel, uint8_t Crystal, uint8_t Buffer_on_off, uint8_t Bipolar_Unipolar, uint8_t Gain, uint8_t Calibration) {
	/*Сбросим статус ножки DRDY*/
	AD7705_DRDY_Status = false;
	/*Выполним ресет АЦП*/
	AD7705_RESET_ON;
	AD7705_RESET_OFF;

	uint8_t Init_Data[4] = { 0, };

	/*Зайдем в Communication register, выберем канал и перейдем в Clock register*/
	Init_Data[0] = 0x20 | Channel;
	/*В Clock register выбираем тип кварца, который поставили на плату (4.9512 МГц, либо 2.4576 МГц)*/
	Init_Data[1] = Crystal;
	/*Зайдем в Communication register, выберем канал и перейдем в Setup register*/
	Init_Data[2] = 0x10 | Channel;
	/*В Setup register включим/выключим буфер, выберем режим, униполярный или биполярный, настроим усиление, проведем калибровку*/
	Init_Data[3] = Buffer_on_off | Bipolar_Unipolar | Gain | Calibration;

	AD7705_CS_ON;
	CMSIS_SPI_Data_Transmit_8BIT(SPI, (uint8_t*) Init_Data, 4, 100);
	AD7705_CS_OFF;

}

/*
 **************************************************************************************************
 *  @breif Функция чтения данных с АЦП AD7705
 *  @attention Инициализация, как я понял, выполняется каждый раз перед сменой канала,
 *  иначе будет показывать неправильно.
 *  @param  *SPI или *hspi - шина SPI
 *  @param  Channel - канал, который предварительно настроили и теперь опрашиваем (define)
 *  @retval  Возвращает 16-битное значение, которое соответствует замеру АЦП
 **************************************************************************************************
 */
uint16_t AD7705_ReadData(SPI_TypeDef* SPI, uint8_t Channel) {
	/*Сбросим статус ножки DRDY*/
	AD7705_DRDY_Status = false;
	/*Подготовим команду опроса данных*/
	uint8_t Command = 0x38;
	uint8_t Rx_Data[2] = { 0, };
	/*Выберем нужный канал*/
	Command |= Channel;

	AD7705_CS_ON;
	/*Отправим запрос на получение данных*/
	CMSIS_SPI_Data_Transmit_8BIT(SPI, (uint8_t*) &Command, 1, 100);
	/*Примем 2 байта*/
	CMSIS_SPI_Data_Receive_8BIT(SPI, (uint8_t*) Rx_Data, 2, 100);
	/*Соберем все в 16 бит*/
	uint16_t ADC_val = 0;
	ADC_val = ((uint16_t) Rx_Data[0] << 8U) | Rx_Data[1];
	AD7705_CS_OFF;
	return ADC_val;
}

/*
 **************************************************************************************************
 *  @breif Функция ожидания низкого уровня ножки DRDY
 *  @attention Выполняется каждый раз перед новым чтением данных.
 *  Данная функция нежелательна и скорее демонстрационная, т.к. она блокирует цикл,
 *  а ожидание низкого уровня занимает приличное время...
 *  Рекомендуется ножку DRDY просто опрашивать в цикле, либо сделать по ней прерывание EXTI,
 *  а уже по событию продолжать работать с АЦП.
 **************************************************************************************************
 */
void AD7705_Wait_DRDY(void) {
	while (AD7705_CHECK_DRDY) {
	};
	/*Сбросим статус ножки DRDY*/
	AD7705_DRDY_Status = true;
}

